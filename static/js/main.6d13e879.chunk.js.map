{"version":3,"sources":["pathfinding/Node/Node.jsx","algorithms/dijkstra.js","pathfinding/grid.jsx","App.js","reportWebVitals.js","index.js"],"names":["forwardRef","props","ref","row","col","isStart","extraClassName","isFinish","id","className","dijkstra","grid","startNode","finishNode","visitedNodes","distance","unvisitedNodes","nodes","node","push","getAllNodes","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","length","filter","neighbor","getUnvisitedNeighbors","previousNode","Grid","useState","setGrid","isVisualising","setIsVisualising","visitedNodeOrder","useRef","nodeRefArray","useEffect","currentRow","createNode","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","current","visualiseDijkstra","resetGrid","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","disabled","onClick","map","rowId","nodeId","el","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.6d13e879.chunk.js","sourcesContent":["import React, { forwardRef } from \"react\";\nimport \"./Node.css\";\n\nexport default forwardRef((props, ref) => {\n  const { row, col, isStart, isFinish } = props;\n  const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : \"\";\n  return (\n    <div\n      id={`node-${row}-${col}`}\n      ref={ref}\n      className={`node ${extraClassName}`}\n    ></div>\n  );\n});\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (true) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport Node from \"./Node/Node.jsx\";\nimport {\n  getNodesInShortestPathOrder,\n  dijkstra,\n} from \"../algorithms/dijkstra.js\";\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 5;\nconst FINISH_NODE_COL = 35;\n\nexport default function Grid() {\n  const [grid, setGrid] = useState([]);\n  const [isVisualising, setIsVisualising] = useState(false);\n  const visitedNodeOrder = useRef([])\n  const nodeRefArray = useRef([]);\n\n\n  useEffect(() => {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      grid.push(currentRow);\n    }\n    setGrid(grid);\n  }, []);\n\n\n  const animateDijkstra = (visitedNodeOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodeOrder.length; i++) {\n      if (i === visitedNodeOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 5 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodeOrder[i];\n        nodeRefArray.current[`${node.row}-${node.col}`].className =\n          \"node node-visited\";\n      }, 5 * i);\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        nodeRefArray.current[`${node.row}-${node.col}`].className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n    setTimeout(() => setIsVisualising(false), 1250);\n  };\n\n  const visualiseDijkstra = () => {\n    // disable if already visualising the algorithm\n    resetGrid()\n    setIsVisualising(true);\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    visitedNodeOrder.current = dijkstra(grid, startNode, finishNode)\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode)\n    animateDijkstra(visitedNodeOrder.current, nodesInShortestPathOrder);\n  };\n\n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      isVisited: false,\n      distance: Infinity,\n      previousNode: null,\n    };\n  };\n\n  const resetGrid = () => {\n    for (let i = 0; i < visitedNodeOrder.current.length; i++) {\n      const node = visitedNodeOrder.current[i];\n      if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n        nodeRefArray.current[`${node.row}-${node.col}`].className = \"node node-start\"\n      } else if (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL) {\n        nodeRefArray.current[`${node.row}-${node.col}`].className = \"node node-finish\"\n      } else {\n        nodeRefArray.current[`${node.row}-${node.col}`].className = \"node\"\n      }\n    }\n  }\n\n  return (\n    <>\n      <button disabled={isVisualising} onClick={() => resetGrid()}>\n        Reset\n    </button>\n      <button disabled={isVisualising} onClick={() => visualiseDijkstra()}>\n        Visualise Dijkstra's Algorithm\n      </button>\n      <div className=\"grid\">\n        {grid.map((row, rowId) => {\n          return (\n            <div key={rowId}>\n              {row.map((node, nodeId) => {\n                const { row, col, isStart, isFinish } = node;\n                return (\n                  <Node\n                    key={nodeId}\n                    ref={(el) => (nodeRefArray.current[`${row}-${col}`] = el)}\n                    row={row}\n                    col={col}\n                    isStart={isStart}\n                    isFinish={isFinish}\n                  ></Node>\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n}\n","import React from \"react\";\nimport \"./App.css\";\nimport Grid from \"./pathfinding/grid.jsx\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Grid></Grid>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}