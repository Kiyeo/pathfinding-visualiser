{"version":3,"sources":["components/Node.jsx","algorithms/dijkstra.js","App.js","reportWebVitals.js","index.js"],"names":["forwardRef","props","ref","row","col","isStart","isFinish","handleMouseDownForNode","handleMouseEnterForNode","handleMouseUpForNode","displayWeight","isShowWeight","extraClassName","id","onMouseDown","onMouseEnter","onMouseUp","onDragStart","e","preventDefault","stopPropagation","className","Infinity","dijkstra","grid","startNode","finishNode","isRandomWeights","visitedNodes","distance","cumulativeWeight","unvisitedNodes","nodes","node","push","getAllNodes","heapSortNodesByDistance","closestNode","shift","isWall","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","length","filter","neighbor","getUnvisitedNeighbors","previousNode","App","useRef","getInitialGrid","currentRow","createNode","current","useState","setGrid","isVisualising","setIsVisualising","isPostVisualise","setIsPostVisualise","visitedNodeOrder","nodeRefArray","isResetting","timeOut","isMousePressed","setIsMousePressed","isNewStartNode","setIsNewStartNode","isNewFinishNode","setIsNewFinishNode","useEffect","setNewStartOrFinishNode","newGrid","slice","prevNode","currentStartFinishNode","type","newStartFinishNode","prevStartFinishNode","rmPrevStartNode","animateShortestPath","nodesInShortestPathOrder","delay","i","setTimeout","visualiseDijkstra","resetVisitedNodeCSS","nodeStart","nodeFinish","currentNode","unshift","getNodesInShortestPathOrder","nodeRef","innerText","animateDijkstra","onClick","forEach","timer","clearTimeout","initialGrid","resetGrid","disabled","startNodeRow","startNodeCol","finishNodeRow","finishNodeCol","Math","random","ceil","randomWeights","onMouseLeave","style","margin","display","gridTemplateColumns","width","NUM_COLUMNS","map","el","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.f80cc745.chunk.js","sourcesContent":["import React, { forwardRef } from \"react\";\nimport \"./Node.css\";\n\nexport default forwardRef((props, ref) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    handleMouseDownForNode,\n    handleMouseEnterForNode,\n    handleMouseUpForNode,\n    displayWeight,\n    isShowWeight,\n  } = props;\n  const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : \"\";\n\n  return (\n    <div\n      id={`${row}-${col}`}\n      onMouseDown={() => {\n        handleMouseDownForNode(row, col);\n      }}\n      onMouseEnter={() => {\n        handleMouseEnterForNode(row, col);\n      }}\n      onMouseUp={() => {\n        handleMouseUpForNode();\n      }}\n      onDragStart={(e) => {\n        // Block drag default event\n        e.preventDefault();\n        e.stopPropagation();\n      }}\n      ref={ref}\n      className={`node ${extraClassName}`}\n    >\n      {isStart\n        ? \"\"\n        : isFinish\n        ? \"\"\n        : displayWeight === Infinity\n        ? \"\"\n        : isShowWeight\n        ? \"\"\n        : displayWeight}\n    </div>\n  );\n});\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode, isRandomWeights) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  startNode.cumulativeWeight = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (true) {\n    heapSortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid, isRandomWeights);\n  }\n}\n\nfunction heapSortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, isRandomWeights) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    if (isRandomWeights) {\n      neighbor.distance = neighbor.cumulativeWeight + node.cumulativeWeight;\n      neighbor.cumulativeWeight = neighbor.distance;\n    } else {\n      neighbor.distance = node.distance + 1;\n    }\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  heapSortNodesByDistance(neighbors);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport Node from \"./components/Node.jsx\";\nimport {\n  getNodesInShortestPathOrder,\n  dijkstra,\n} from \"./algorithms/dijkstra.js\";\nimport \"./App.css\";\n\nconst NUM_ROWS = 20;\nconst NUM_COLUMNS = 50;\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nconst App = () => {\n  const startNode = useRef();\n  const finishNode = useRef();\n\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        currentRow.push(createNode(row, col));\n        if (row === START_NODE_ROW && col === START_NODE_COL)\n          startNode.current = { row, col };\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\n          finishNode.current = { row, col };\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  const createNode = (\n    row,\n    col,\n    cumulativeWeight = null,\n    startNode = { row: START_NODE_ROW, col: START_NODE_COL },\n    finishNode = { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\n  ) => {\n    return {\n      row,\n      col,\n      isStart: row === startNode.row && col === startNode.col,\n      isFinish: row === finishNode.row && col === finishNode.col,\n      isVisited: false,\n      distance: Infinity,\n      previousNode: null,\n      displayWeight: cumulativeWeight,\n      cumulativeWeight,\n      isShowWeight: false,\n    };\n  };\n\n  const [grid, setGrid] = useState(() => getInitialGrid());\n  const [isVisualising, setIsVisualising] = useState(false);\n  const [isPostVisualise, setIsPostVisualise] = useState(false);\n  const visitedNodeOrder = useRef([]);\n  const nodeRefArray = useRef([]);\n  const isResetting = useRef(false);\n  const isRandomWeights = useRef(false);\n  const timeOut = useRef([]);\n  const [isMousePressed, setIsMousePressed] = useState(false);\n  const [isNewStartNode, setIsNewStartNode] = useState(false);\n  const [isNewFinishNode, setIsNewFinishNode] = useState(false);\n\n  useEffect(() => {}, []);\n\n  const handleMouseDownForNode = (row, col) => {\n    setIsMousePressed(true);\n    if (\n      row === startNode.current.row &&\n      col === startNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewStartNode(true);\n    }\n    if (\n      row === finishNode.current.row &&\n      col === finishNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewFinishNode(true);\n    }\n  };\n\n  const handleMouseEnterForNode = (row, col) => {\n    if (!isMousePressed && !isVisualising) return;\n    if (\n      isNewStartNode &&\n      !(row === finishNode.current.row && col === finishNode.current.col)\n    ) {\n      const newGrid = setNewStartOrFinishNode(grid, row, col);\n      setGrid(newGrid);\n    }\n    if (\n      isNewFinishNode &&\n      !(row === startNode.current.row && col === startNode.current.col)\n    ) {\n      const newGrid = setNewStartOrFinishNode(grid, row, col);\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseUpForNode = () => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const handleMouseLeaveForGrid = () => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const setNewStartOrFinishNode = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const prevNode = newGrid[row][col];\n    const currentStartFinishNode = isNewStartNode\n      ? startNode.current\n      : finishNode.current;\n    const type = isNewStartNode ? \"isStart\" : \"isFinish\";\n    const newStartFinishNode = {\n      ...prevNode,\n      [type]: true,\n    };\n    const prevStartFinishNode =\n      newGrid[currentStartFinishNode.row][currentStartFinishNode.col];\n    const rmPrevStartNode = {\n      ...prevStartFinishNode,\n      [type]: false,\n    };\n    newGrid[row][col] = newStartFinishNode;\n    newGrid[currentStartFinishNode.row][\n      currentStartFinishNode.col\n    ] = rmPrevStartNode;\n    if (isNewStartNode) {\n      startNode.current = { row, col };\n    } else {\n      finishNode.current = { row, col };\n    }\n    return newGrid;\n  };\n\n  const animateDijkstra = (visitedNodeOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodeOrder.length; i++) {\n      if (i === visitedNodeOrder.length) {\n        timeOut.current.push(\n          setTimeout(() => {\n            animateShortestPath(nodesInShortestPathOrder);\n          }, 5 * i)\n        );\n        return;\n      }\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = visitedNodeOrder[i];\n          const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n          if (isRandomWeights.current)\n            nodeRef.innerText = `${node.cumulativeWeight}`;\n          nodeRef.className = \"node node-visited\";\n        }, 5 * i)\n      );\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    let delay = 0;\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      delay = i;\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          nodeRefArray.current[`${node.row}-${node.col}`].className =\n            \"node node-shortest-path\";\n        }, 50 * i)\n      );\n    }\n    timeOut.current.push(setTimeout(() => setIsVisualising(false), 50 * delay));\n    setIsPostVisualise(true);\n  };\n\n  const visualiseDijkstra = () => {\n    // disable if already visualising the algorithm\n    //resetGrid();\n    if (isPostVisualise) resetVisitedNodeCSS();\n    setIsVisualising(true);\n    const nodeStart = grid[startNode.current.row][startNode.current.col];\n    const nodeFinish = grid[finishNode.current.row][finishNode.current.col];\n    visitedNodeOrder.current = dijkstra(\n      grid,\n      nodeStart,\n      nodeFinish,\n      isRandomWeights.current\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(nodeFinish);\n    animateDijkstra(visitedNodeOrder.current, nodesInShortestPathOrder);\n  };\n\n  const resetGrid = () => {\n    isRandomWeights.current = false;\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    isResetting.current = true;\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n    resetVisitedNodeCSS();\n  };\n\n  const resetVisitedNodeCSS = () => {\n    const nodeStart = isPostVisualise\n      ? startNode.current\n      : { row: START_NODE_ROW, col: START_NODE_COL };\n    const nodeFinish = isPostVisualise\n      ? finishNode.current\n      : { row: FINISH_NODE_ROW, col: FINISH_NODE_COL };\n    for (let i = 0; i < visitedNodeOrder.current.length; i++) {\n      const node = visitedNodeOrder.current[i];\n      const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n      if (node.row === nodeStart.row && node.col === nodeStart.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-start\";\n      } else if (node.row === nodeFinish.row && node.col === nodeFinish.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-finish\";\n      } else {\n        if (isPostVisualise && isRandomWeights.current) {\n          nodeRef.innerText = `${node.displayWeight}`;\n        } else {\n          nodeRef.innerText = \"\";\n        }\n        nodeRef.className = \"node\";\n      }\n    }\n  };\n\n  const randomWeights = () => {\n    isRandomWeights.current = true;\n    const grid = [];\n    const startNodeRow = startNode.current.row;\n    const startNodeCol = startNode.current.col;\n    const finishNodeRow = finishNode.current.row;\n    const finishNodeCol = finishNode.current.col;\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        const nodeRef = nodeRefArray.current[`${row}-${col}`];\n        if (row === startNodeRow && col === startNodeCol) {\n          currentRow.push(\n            createNode(\n              startNodeRow,\n              startNodeCol,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.className = \"node node-start\";\n        } else if (row === finishNodeRow && col === finishNodeCol) {\n          currentRow.push(\n            createNode(\n              finishNodeRow,\n              finishNodeCol,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.className = \"node node-finish\";\n        } else {\n          currentRow.push(\n            createNode(\n              row,\n              col,\n              Math.random() > 0.5 ? Math.ceil(Math.random() * 4) : 1,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.className = \"node\";\n        }\n      }\n      grid.push(currentRow);\n    }\n    setGrid(grid);\n  };\n\n  return (\n    <div className=\"App\">\n      <button onClick={() => resetGrid()}>Reset</button>\n      <button\n        disabled={isVisualising || isPostVisualise}\n        onClick={() => randomWeights()}\n      >\n        Random Weights\n      </button>\n      <button disabled={isVisualising} onClick={() => visualiseDijkstra()}>\n        Visualise Dijkstra's Algorithm\n      </button>\n      <div\n        className=\"grid\"\n        onMouseLeave={() => handleMouseLeaveForGrid()}\n        style={{\n          margin: \"100px auto\",\n          display: \"grid\",\n          gridTemplateColumns: `repeat(${NUM_COLUMNS}, 25px)`,\n          //makes the grid width relative to node dimension\n          width: `${NUM_COLUMNS * 25}px`,\n        }}\n      >\n        {grid.map((row) =>\n          row.map((node) => {\n            const {\n              row,\n              col,\n              isStart,\n              isFinish,\n              isVisited,\n              displayWeight,\n              cumulativeWeight,\n              isShowWeight,\n            } = node;\n            return (\n              <Node\n                key={`${row}-${col}`}\n                ref={(el) => (nodeRefArray.current[`${row}-${col}`] = el)}\n                handleMouseDownForNode={(row, col) =>\n                  handleMouseDownForNode(row, col)\n                }\n                handleMouseEnterForNode={(row, col) =>\n                  handleMouseEnterForNode(row, col)\n                }\n                handleMouseUpForNode={() => handleMouseUpForNode()}\n                row={row}\n                col={col}\n                isStart={isStart}\n                isFinish={isFinish}\n                isVisited={isVisited}\n                displayWeight={displayWeight}\n                cumulativeWeight={cumulativeWeight}\n                isShowWeight={isShowWeight}\n              ></Node>\n            );\n          })\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}