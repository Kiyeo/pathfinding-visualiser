{"version":3,"sources":["components/Node.jsx","components/Button.jsx","algorithms/dijkstra.js","App.js","algorithms/animateDijkstra.js","reportWebVitals.js","index.js"],"names":["forwardRef","props","ref","row","col","isWall","isStart","isFinish","handlePointerDownForNode","handlePointerEnterForNode","handleTouchMoveForNode","handlePointerUpForNode","displayWeight","isShowWeight","extraClassName","id","onPointerDown","onMouseEnter","onTouchMove","e","onPointerUp","onDragStart","preventDefault","stopPropagation","className","Infinity","Button","type","handleFunction","disable","title","disabledTitle","isVisualising","isPostVisualise","text","replace","match","toUpperCase","displayText","displayTitle","shape","disabled","onClick","dijkstra","grid","startNode","finishNode","isRandomWeights","isVisited","finishNodeNeighbours","getUnvisitedNeighbors","finishNodeNeighbourVisits","visitedNodes","distance","cumulativeWeight","unvisitedNodes","nodes","node","push","getAllNodes","heapSortNodesByDistance","closestNode","shift","length","finishNodeNeighbour","filter","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbor","distace","previousNode","neighbors","neighborOperations","totalRows","totalCols","i","operation","newRow","newCol","NUM_ROWS","NUM_COLUMNS","NODE_REM","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","animateShortestPath","nodeRefArray","timeOut","nodesInShortestPathOrder","setIsVisualising","setIsPostVisualise","delay","current","setTimeout","startNodeRow","startNodeCol","animateDijkstra","isGenerateWeights","visitedNodeOrder","nodeRef","innerText","App","useRef","getInitialGrid","useCallback","currentRow","createNode","isShowCumulativeWeight","useState","setGrid","isResetting","isMousePressed","setIsMousePressed","isNewStartNode","setIsNewStartNode","isNewFinishNode","setIsNewFinishNode","toggleWeightHistory","isToggle","isRecoverToggle","useLayoutEffect","updateSize","window","innerHeight","Math","floor","innerWidth","addEventListener","removeEventListener","isStartRef","isFinishRef","isNotStartFinishRef","setNewStartOrFinishNode","setWall","touchElement","setTouchElement","handlePointerUpForGrid","newGrid","slice","prevNodeValues","wallNode","currentStartFinishNode","newStartFinishNode","prevStartFinishNodeValues","ceil","random","prevStartFinishNode","resetVisitedNodeCSS","nodeStart","nodeFinish","perserveGrid","isRestore","finishNodeRow","finishNodeCol","currNode","style","display","forEach","timer","clearTimeout","initialGrid","resetGrid","restoreGrid","isToggleWeightBool","generateWeights","currentNode","unshift","getNodesInShortestPathOrder","visualiseDijkstra","onMouseLeave","undefined","margin","marginTop","gridTemplateColumns","gridTemplateRows","gap","width","touchAction","fontFamily","fontSize","color","cursor","map","el","isNotVisualisation","isMouse","x","clientX","touches","y","clientY","element","document","elementFromPoint","rowAndCol","split","Number","classList","contains","handlePointerMoveForNode","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.0e3f3cbf.chunk.js","sourcesContent":["import React, { forwardRef } from \"react\";\nimport \"./Node.css\";\nimport \"../index.css\";\n\nexport default forwardRef((props, ref) => {\n  const {\n    row,\n    col,\n    isWall,\n    isStart,\n    isFinish,\n    handlePointerDownForNode,\n    handlePointerEnterForNode,\n    handleTouchMoveForNode,\n    handlePointerUpForNode,\n    displayWeight,\n    isShowWeight,\n  } = props;\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : \"\";\n\n  return (\n    <div\n      id={`${row}-${col}`}\n      onPointerDown={() => handlePointerDownForNode()}\n      onMouseEnter={() => handlePointerEnterForNode(row, col)}\n      onTouchMove={(e) => handleTouchMoveForNode(e)}\n      onPointerUp={() => handlePointerUpForNode()}\n      onDragStart={(e) => {\n        // Block drag default event\n        e.preventDefault();\n        e.stopPropagation();\n      }}\n      ref={ref}\n      className={`node ${extraClassName}`}\n    >\n      {isStart\n        ? \"\"\n        : isFinish\n        ? \"\"\n        : displayWeight === Infinity\n        ? \"\"\n        : isShowWeight && !isWall\n        ? \"\"\n        : displayWeight}\n    </div>\n  );\n});\n","import React from \"react\";\nimport \"./Button.css\";\n\nexport default function Button(props) {\n  const {\n    type,\n    handleFunction,\n    disable,\n    title,\n    disabledTitle,\n    isVisualising,\n    isPostVisualise,\n  } = props;\n  const text = type\n    .replace(\"-\", \" \")\n    .replace(/(^\\w{1})|(\\s{1}\\w{1})/g, (match) => match.toUpperCase());\n  const displayText =\n    type === \"visualise\" && isPostVisualise && !isVisualising\n      ? \"Revisualise\"\n      : type === \"visualise\" && isVisualising\n      ? \"Visualising\"\n      : text;\n  const displayTitle =\n    type === \"restore\" && disable\n      ? disabledTitle\n      : type === \"toggle-weights\" && !disable\n      ? title\n      : type === \"toggle-weights\" && disable\n      ? disabledTitle\n      : \"\";\n  const className = isVisualising\n    ? `${type} visualising loading`\n    : isPostVisualise\n    ? `${type} notify`\n    : type;\n\n  return (\n    <button\n      shape={\"round\"}\n      title={displayTitle}\n      className={className}\n      disabled={disable}\n      onClick={() => handleFunction()}\n    >\n      {isVisualising && <i className={\"spinner\"} />}\n      {displayText}\n    </button>\n  );\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode, isRandomWeights) {\n  finishNode.isVisited = false;\n  finishNode.isWall = false;\n  const finishNodeNeighbours = getUnvisitedNeighbors(finishNode, grid);\n  let finishNodeNeighbourVisits = 0;\n  const visitedNodes = [];\n  startNode.distance = 0;\n  startNode.cumulativeWeight = 0;\n  startNode.isWall = false;\n  const unvisitedNodes = getAllNodes(grid);\n  // terminates when finishNode is reached\n  while (true) {\n    heapSortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (isRandomWeights && finishNodeNeighbours.length > 1) {\n      for (const finishNodeNeighbour of finishNodeNeighbours) {\n        const row = finishNodeNeighbour.row;\n        const col = finishNodeNeighbour.col;\n        if (\n          closestNode.row === row &&\n          closestNode.col === col &&\n          closestNode.isVisited\n        ) {\n          finishNodeNeighbourVisits++;\n        }\n      }\n      if (finishNodeNeighbourVisits === finishNodeNeighbours.length) {\n        finishNodeNeighbours.filter((node) => (node.isVisited = false));\n        return visitedNodes;\n      }\n    } else {\n      if (closestNode === finishNode) return visitedNodes;\n    }\n    updateUnvisitedNeighbors(closestNode, grid, isRandomWeights);\n  }\n}\n\nfunction heapSortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, isRandomWeights) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    // for weighted simulation\n    if (isRandomWeights) {\n      if (neighbor.distace === Infinity) {\n        neighbor.distance = neighbor.displayWeight + node.cumulativeWeight;\n        neighbor.cumulativeWeight = neighbor.distance;\n        neighbor.previousNode = node;\n      }\n      // checks and updates the neighbors for the path with the less cost\n      else if (\n        neighbor.distance >\n        neighbor.displayWeight + node.cumulativeWeight\n      ) {\n        neighbor.distance = neighbor.displayWeight + node.cumulativeWeight;\n        neighbor.cumulativeWeight = neighbor.distance;\n        neighbor.previousNode = node;\n      }\n    }\n    // for unweighted simulation\n    else {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  const neighborOperations = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n  const totalRows = grid.length;\n  const totalCols = grid[0].length;\n  //constant opeations => 4 values\n  for (let i = 0; i < neighborOperations.length; i++) {\n    const operation = neighborOperations[i];\n    const x = operation[0];\n    const y = operation[1];\n    const newRow = row + x;\n    const newCol = col - y;\n    if (\n      newRow >= 0 &&\n      newRow < totalRows &&\n      newCol >= 0 &&\n      newCol < totalCols &&\n      !grid[newRow][newCol].isWall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useLayoutEffect, useCallback, useRef } from \"react\";\nimport Node from \"./components/Node.jsx\";\nimport Button from \"./components/Button.jsx\";\nimport {\n  getNodesInShortestPathOrder,\n  dijkstra,\n} from \"./algorithms/dijkstra.js\";\nimport \"./App.css\";\nimport animateDijkstra from \"./algorithms/animateDijkstra\";\n\nlet NUM_ROWS;\n\nconst SMALL_NUM_ROWS = 10;\nlet NUM_COLUMNS;\nlet NODE_REM;\n\nlet START_NODE_ROW;\nlet START_NODE_COL;\nlet FINISH_NODE_ROW;\nlet FINISH_NODE_COL;\n\nconst App = () => {\n  const startNode = useRef();\n  const finishNode = useRef();\n\n  const getInitialGrid = useCallback(() => {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        currentRow.push(createNode(row, col));\n        if (row === START_NODE_ROW && col === START_NODE_COL)\n          startNode.current = { row, col };\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\n          finishNode.current = { row, col };\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  }, []);\n\n  const createNode = (\n    row,\n    col,\n    isWall = false,\n    cumulativeWeight = null,\n    startNode = { row: START_NODE_ROW, col: START_NODE_COL },\n    finishNode = { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\n  ) => {\n    return {\n      row,\n      col,\n      isWall: isWall,\n      isStart: row === startNode.row && col === startNode.col,\n      isFinish: row === finishNode.row && col === finishNode.col,\n      isVisited: false,\n      distance: Infinity,\n      previousNode: null,\n      displayWeight: cumulativeWeight,\n      cumulativeWeight,\n      isShowCumulativeWeight: false,\n    };\n  };\n\n  const [grid, setGrid] = useState(() => getInitialGrid());\n  const [isVisualising, setIsVisualising] = useState(false);\n  const [isPostVisualise, setIsPostVisualise] = useState(false);\n  const visitedNodeOrder = useRef([]);\n  const nodeRefArray = useRef([]);\n  const isResetting = useRef(false);\n  const isGenerateWeights = useRef(false);\n  const timeOut = useRef([]);\n  const [isMousePressed, setIsMousePressed] = useState(false);\n  const [isNewStartNode, setIsNewStartNode] = useState(false);\n  const [isNewFinishNode, setIsNewFinishNode] = useState(false);\n  const toggleWeightHistory = useRef([]);\n  const isToggle = useRef(false);\n  const isRecoverToggle = useRef(false);\n\n  useLayoutEffect(() => {\n    function updateSize() {\n      setTimeout(() => {\n        if (window.innerHeight > 500) {\n          NUM_ROWS = Math.floor(window.innerHeight * 0.003) * 10;\n          if (NUM_ROWS === 10) NUM_ROWS = NUM_ROWS + 5;\n        } else {\n          NUM_ROWS = SMALL_NUM_ROWS;\n        }\n        NUM_COLUMNS = Math.floor(window.innerWidth * 0.003) * 10;\n        NODE_REM = 2;\n\n        START_NODE_ROW = Math.floor(NUM_ROWS * 0.5);\n        START_NODE_COL = Math.floor(NUM_COLUMNS * 0.25);\n        FINISH_NODE_ROW = Math.floor(NUM_ROWS * 0.5);\n        FINISH_NODE_COL = Math.floor(NUM_COLUMNS * 0.75);\n\n        setGrid(getInitialGrid());\n      }, 500);\n    }\n    window.addEventListener(\"resize\", () => {\n      if (window.innerHeight > 480) updateSize();\n    });\n    updateSize();\n    return () =>\n      window.removeEventListener(\"resize\", () => {\n        if (window.innerHeight > 480) updateSize();\n      });\n  }, [getInitialGrid]);\n\n  const handlePointerDownForNode = (row, col) => {\n    setIsMousePressed(true);\n    const isStartRef =\n      row === startNode.current.row && col === startNode.current.col;\n\n    const isFinishRef =\n      row === finishNode.current.row && col === finishNode.current.col;\n\n    const isNotVisualisation = !isVisualising && !isPostVisualise;\n\n    if (isStartRef && isNotVisualisation) {\n      setIsNewStartNode(true);\n    } else if (isFinishRef && isNotVisualisation) {\n      setIsNewFinishNode(true);\n    } else if (isNotVisualisation) setWall(grid, row, col);\n  };\n\n  const handlePointerEnterForNode = (row, col) => {\n    if (!isMousePressed && !isVisualising) return;\n\n    const isStartRef =\n      row === startNode.current.row && col === startNode.current.col;\n\n    const isFinishRef =\n      row === finishNode.current.row && col === finishNode.current.col;\n\n    const isNotStartFinishRef = !isStartRef && !isFinishRef;\n\n    if (isNewStartNode && isNotStartFinishRef) {\n      setNewStartOrFinishNode(grid, row, col);\n    } else if (isNewFinishNode && isNotStartFinishRef) {\n      setNewStartOrFinishNode(grid, row, col);\n    } else if (!isVisualising && !isPostVisualise && isNotStartFinishRef)\n      setWall(grid, row, col);\n  };\n\n  // stops touch move from setting the same element multiple times\n  const [touchElement, setTouchElement] = useState(null);\n\n  const handlePointerMoveForNode = (e, isMouse) => {\n    const x = isMouse ? e.clientX : e.touches[0].clientX;\n    const y = isMouse ? e.clientY : e.touches[0].clientY;\n\n    const element = document.elementFromPoint(x, y);\n    const rowAndCol = element.id.split(\"-\");\n\n    const row = Number(rowAndCol[0]);\n    const col = Number(rowAndCol[1]);\n\n    if (element.classList.contains(\"node\") && touchElement !== element) {\n      setTouchElement(element);\n      handlePointerEnterForNode(row, col);\n    }\n    return;\n  };\n\n  const handlePointerUpForNode = (\n    setIsMousePressed,\n    setIsNewStartNode,\n    setIsNewFinishNode\n  ) => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const handlePointerUpForGrid = (\n    setIsMousePressed,\n    setIsNewStartNode,\n    setIsNewFinishNode\n  ) => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const handleMouseLeaveForGrid = () => {\n    window.addEventListener(\"mouseup\", () =>\n      handlePointerUpForGrid(\n        setIsMousePressed,\n        setIsNewStartNode,\n        setIsNewFinishNode\n      )\n    );\n  };\n\n  const setWall = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const prevNodeValues = newGrid[row][col];\n    const wallNode = {\n      ...prevNodeValues,\n      displayWeight: prevNodeValues.displayWeight,\n      isShowWeight: false,\n      isWall: !prevNodeValues.isWall,\n    };\n    newGrid[row][col] = wallNode;\n    setGrid(newGrid);\n  };\n\n  const setNewStartOrFinishNode = (grid, row, col) => {\n    const newGrid = grid.slice();\n    // keep the new start or finish nodes previous (json) values\n    const prevNodeValues = newGrid[row][col];\n    const currentStartFinishNode = isNewStartNode\n      ? startNode.current\n      : finishNode.current;\n    // only change the type of the start or finish node\n    const type = isNewStartNode ? \"isStart\" : \"isFinish\";\n    const newStartFinishNode = {\n      ...prevNodeValues,\n      [type]: true,\n    };\n    const prevStartFinishNodeValues =\n      newGrid[currentStartFinishNode.row][currentStartFinishNode.col];\n\n    const displayWeight =\n      prevStartFinishNodeValues.displayWeight === null &&\n      isGenerateWeights.current &&\n      !prevStartFinishNodeValues.isWall\n        ? Math.ceil(Math.random() * 10)\n        : prevStartFinishNodeValues.displayWeight;\n\n    // change the old start or finish node type to false\n    const prevStartFinishNode = {\n      ...prevStartFinishNodeValues,\n      displayWeight: displayWeight,\n      [type]: false,\n    };\n    newGrid[row][col] = newStartFinishNode;\n    newGrid[currentStartFinishNode.row][\n      currentStartFinishNode.col\n    ] = prevStartFinishNode;\n\n    if (isGenerateWeights.current) {\n      toggleWeightHistory.current[currentStartFinishNode.row][\n        currentStartFinishNode.col\n      ] = prevStartFinishNode;\n    }\n\n    // update start or finish node reference\n    if (isNewStartNode) {\n      startNode.current = { row, col };\n    } else {\n      finishNode.current = { row, col };\n    }\n    setGrid(newGrid);\n  };\n\n  const visualiseDijkstra = () => {\n    // resets css when resimulating\n    if (isPostVisualise) resetVisitedNodeCSS();\n    setIsVisualising(true);\n    const nodeStart = grid[startNode.current.row][startNode.current.col];\n    const nodeFinish = grid[finishNode.current.row][finishNode.current.col];\n    visitedNodeOrder.current = dijkstra(\n      grid,\n      nodeStart,\n      nodeFinish,\n      isGenerateWeights.current\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(nodeFinish);\n    animateDijkstra(\n      startNode,\n      nodeRefArray,\n      timeOut,\n      isGenerateWeights,\n      visitedNodeOrder.current,\n      nodesInShortestPathOrder,\n      setIsVisualising,\n      setIsPostVisualise\n    );\n  };\n\n  const resetGrid = () => {\n    isGenerateWeights.current = false;\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    isResetting.current = true;\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n    resetVisitedNodeCSS();\n    toggleWeightHistory.current = [];\n  };\n\n  const resetVisitedNodeCSS = () => {\n    const nodeStart = isPostVisualise\n      ? startNode.current\n      : { row: START_NODE_ROW, col: START_NODE_COL };\n\n    const nodeFinish = isPostVisualise\n      ? finishNode.current\n      : { row: FINISH_NODE_ROW, col: FINISH_NODE_COL };\n\n    for (let i = 0; i < visitedNodeOrder.current.length; i++) {\n      const node = visitedNodeOrder.current[i];\n      const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n\n      if (node.row === nodeStart.row && node.col === nodeStart.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-start\";\n      } else if (node.row === nodeFinish.row && node.col === nodeFinish.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-finish\";\n      } else {\n        if ((isVisualising || isPostVisualise) && isGenerateWeights.current) {\n          nodeRef.innerText = `${node.displayWeight}`;\n        } else {\n          nodeRef.innerText = \"\";\n        }\n        nodeRef.className = \"node\";\n      }\n    }\n  };\n\n  const restoreGrid = (isRestore = true) => {\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    resetVisitedNodeCSS();\n    perserveGrid(grid, isRestore);\n  };\n\n  const perserveGrid = (grid, isRestore) => {\n    const newGrid = [];\n    const startNodeRow = startNode.current.row;\n    const startNodeCol = startNode.current.col;\n    const finishNodeRow = finishNode.current.row;\n    const finishNodeCol = finishNode.current.col;\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        const nodeRef = nodeRefArray.current[`${row}-${col}`];\n        if (row === startNodeRow && col === startNodeCol) {\n          currentRow.push(\n            createNode(\n              startNodeRow,\n              startNodeCol,\n              false,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n\n          nodeRef.innerText = \"\";\n          nodeRef.className = \"node node-start\";\n        } else if (row === finishNodeRow && col === finishNodeCol) {\n          currentRow.push(\n            createNode(\n              finishNodeRow,\n              finishNodeCol,\n              false,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n\n          nodeRef.innerText = \"\";\n          nodeRef.className = \"node node-finish\";\n        } else {\n          const currNode = grid[row][col];\n\n          const displayWeight = isRecoverToggle.current\n            ? toggleWeightHistory.current[row][col].displayWeight\n            : isToggle.current\n            ? null\n            : isRestore\n            ? currNode.displayWeight\n            : Math.random() > 0.5\n            ? Math.ceil(Math.random() * 10)\n            : 1;\n\n          currentRow.push(\n            createNode(\n              row,\n              col,\n              currNode.isWall,\n              displayWeight,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.className = currNode.isWall ? \"node node-wall\" : \"node\";\n        }\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n    return newGrid;\n  };\n\n  const generateWeights = (grid, isToggleWeightBool, isRestore = false) => {\n    isGenerateWeights.current = isToggleWeightBool;\n    isToggle.current = false;\n    const newGrid = perserveGrid(grid, isRestore);\n    if (isGenerateWeights.current) {\n      toggleWeightHistory.current = newGrid;\n    }\n  };\n\n  const toggleWeights = () => {\n    isGenerateWeights.current = !isGenerateWeights.current;\n    isToggle.current = !isToggle.current;\n    if (isToggle.current) {\n      perserveGrid(grid, false);\n    } else {\n      isRecoverToggle.current = true;\n      perserveGrid(grid, false);\n      isRecoverToggle.current = false;\n    }\n  };\n\n  return (\n    <>\n      <div\n        className=\"galaxy-fold-open-your-device\"\n        style={{ display: \"none\" }}\n      ></div>\n      <div className=\"App\">\n        <div className=\"button-container\">\n          <Button type={\"reset\"} handleFunction={() => resetGrid()}></Button>\n          <Button\n            type={\"restore\"}\n            handleFunction={() => restoreGrid(grid)}\n            disable={!(isVisualising || isPostVisualise)}\n            disabledTitle={\"Restores state before the visualisation\"}\n          ></Button>\n          <Button\n            type={\"toggle-weights\"}\n            handleFunction={() => toggleWeights()}\n            disable={\n              !toggleWeightHistory.current.length ||\n              isVisualising ||\n              isPostVisualise\n            }\n          ></Button>\n          <Button\n            type={\"generate-weights\"}\n            handleFunction={() => generateWeights(grid, true)}\n            disable={isVisualising || isPostVisualise}\n            title={\"Generates random weights to each node. Click to toggle.\"}\n            disabledTitle={\"Can only reassign random weights on restore\"}\n          ></Button>\n          <Button\n            type={\"visualise\"}\n            handleFunction={() => visualiseDijkstra()}\n            disable={isVisualising}\n            isVisualising={isVisualising}\n            isPostVisualise={isPostVisualise}\n          ></Button>\n        </div>\n        <div\n          className=\"grid\"\n          onPointerUp={() =>\n            handlePointerUpForGrid(\n              setIsMousePressed,\n              setIsNewStartNode,\n              setIsNewFinishNode\n            )\n          }\n          onMouseLeave={() => handleMouseLeaveForGrid()}\n          title={\n            isPostVisualise\n              ? \"Click 'Restore' to adjust start, finish and wall nodes\"\n              : undefined\n          }\n          style={{\n            margin: \"auto\",\n            display: \"grid\",\n            marginTop: \"1rem\",\n\n            gridTemplateColumns: `repeat(${NUM_COLUMNS}, ${NODE_REM}rem)`,\n            gridTemplateRows: `repeat(${NUM_ROWS}, ${NODE_REM}rem)`,\n            gap: \"1px\",\n            //makes the grid width relative to sum of all node pixels\n            // 1px === 0.06rem. NUM_COLUMNS * 0.06 is to account for the gap of 1px\n            width: `${NUM_COLUMNS * NODE_REM + NUM_COLUMNS * 0.06}rem`,\n            touchAction: \"none\",\n            fontFamily: \"Alcubierre\",\n            fontSize: \"1rem\",\n            color: \"black\",\n            cursor: isVisualising ? \"progress\" : \"pointer\",\n          }}\n        >\n          {grid.map((row) =>\n            row.map((node) => {\n              const {\n                row,\n                col,\n                isWall,\n                isStart,\n                isFinish,\n                isVisited,\n                displayWeight,\n                cumulativeWeight,\n                isShowCumulativeWeight: isShowWeight,\n              } = node;\n              return (\n                <Node\n                  key={`${row}-${col}`}\n                  ref={(el) => (nodeRefArray.current[`${row}-${col}`] = el)}\n                  handlePointerDownForNode={() =>\n                    handlePointerDownForNode(row, col)\n                  }\n                  handlePointerEnterForNode={() =>\n                    handlePointerEnterForNode(row, col)\n                  }\n                  handleTouchMoveForNode={(e) =>\n                    handlePointerMoveForNode(e, false)\n                  }\n                  handlePointerUpForNode={() =>\n                    handlePointerUpForNode(\n                      setIsMousePressed,\n                      setIsNewStartNode,\n                      setIsNewFinishNode\n                    )\n                  }\n                  row={row}\n                  col={col}\n                  isWall={isWall}\n                  isStart={isStart}\n                  isFinish={isFinish}\n                  isVisited={isVisited}\n                  displayWeight={displayWeight}\n                  cumulativeWeight={cumulativeWeight}\n                  isShowWeight={isShowWeight}\n                ></Node>\n              );\n            })\n          )}\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default App;\n","const animateDijkstra = (\n  startNode,\n  nodeRefArray,\n  timeOut,\n  isGenerateWeights,\n  visitedNodeOrder,\n  nodesInShortestPathOrder,\n  setIsVisualising,\n  setIsPostVisualise\n) => {\n  for (let i = 0; i <= visitedNodeOrder.length; i++) {\n    if (i === visitedNodeOrder.length) {\n      timeOut.current.push(\n        setTimeout(() => {\n          animateShortestPath(\n            startNode,\n            nodeRefArray,\n            timeOut,\n            nodesInShortestPathOrder,\n            setIsVisualising,\n            setIsPostVisualise\n          );\n        }, 5 * i)\n      );\n      return;\n    }\n    timeOut.current.push(\n      setTimeout(() => {\n        const node = visitedNodeOrder[i];\n        const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n        // displays cumulative weight if in random weight simulation\n        if (isGenerateWeights.current)\n          nodeRef.innerText = `${node.cumulativeWeight}`;\n        nodeRef.className = \"node node-visited\";\n      }, 5 * i)\n    );\n  }\n};\n\nconst animateShortestPath = (\n  startNode,\n  nodeRefArray,\n  timeOut,\n  nodesInShortestPathOrder,\n  setIsVisualising,\n  setIsPostVisualise\n) => {\n  let delay = 0;\n  if (nodesInShortestPathOrder[0].isStart) {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      delay = i;\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          nodeRefArray.current[`${node.row}-${node.col}`].className =\n            \"node node-shortest-path\";\n        }, 50 * i)\n      );\n    }\n  } else {\n    const startNodeRow = startNode.current.row;\n    const startNodeCol = startNode.current.col;\n    nodeRefArray.current[`${startNodeRow}-${startNodeCol}`].className =\n      \"node node-start\";\n  }\n  timeOut.current.push(\n    setTimeout(() => {\n      setIsVisualising(false);\n      setIsPostVisualise(true);\n    }, 55 * delay)\n  );\n};\n\nexport default animateDijkstra;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}