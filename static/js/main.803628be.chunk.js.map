{"version":3,"sources":["components/Node.jsx","algorithms/dijkstra.js","App.js","reportWebVitals.js","index.js"],"names":["forwardRef","props","ref","row","col","isStart","isFinish","handleMouseDown","handleMouseEnter","handleMouseUp","extraClassName","onMouseDown","onMouseEnter","onMouseUp","onDragStart","e","preventDefault","stopPropagation","className","dijkstra","grid","startNode","finishNode","visitedNodes","distance","unvisitedNodes","nodes","node","push","getAllNodes","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","length","filter","neighbor","getUnvisitedNeighbors","previousNode","App","useRef","getInitialGrid","currentRow","createNode","current","useState","setGrid","isVisualising","setIsVisualising","isPostVisualise","setIsPostVisualise","visitedNodeOrder","nodeRefArray","isResetting","timeOut","isMousePressed","setIsMousePressed","isNewStartNode","setIsNewStartNode","isNewFinishNode","setIsNewFinishNode","useEffect","setNewStartOrFinishNode","newGrid","slice","prevNode","currentStartFinishNode","type","newStartFinishNode","prevStartFinishNode","rmPrevStartNode","animateShortestPath","nodesInShortestPathOrder","delay","i","setTimeout","visualiseDijkstra","resetVisitedNodeCSS","nodeStart","nodeFinish","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","forEach","timer","clearTimeout","initialGrid","resetGrid","disabled","onMouseLeave","style","margin","display","gridTemplateColumns","width","NUM_COLUMNS","map","el","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.803628be.chunk.js","sourcesContent":["import React, { forwardRef } from \"react\";\nimport \"./Node.css\";\n\nexport default forwardRef((props, ref) => {\n  const {\n    row,\n    col,\n    isStart,\n    isFinish,\n    handleMouseDown,\n    handleMouseEnter,\n    handleMouseUp,\n  } = props;\n  const extraClassName = isFinish ? \"node-finish\" : isStart ? \"node-start\" : \"\";\n\n  return (\n    <div\n      onMouseDown={() => {\n        handleMouseDown(row, col);\n      }}\n      onMouseEnter={() => {\n        handleMouseEnter(row, col);\n      }}\n      onMouseUp={() => {\n        handleMouseUp();\n      }}\n      onDragStart={(e) => {\n        e.preventDefault();\n        e.stopPropagation();\n      }}\n      ref={ref}\n      className={`node ${extraClassName}`}\n    ></div>\n  );\n});\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodes = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (true) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (closestNode === finishNode) return visitedNodes;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { col, row } = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useEffect, useRef } from \"react\";\nimport Node from \"./components/Node.jsx\";\nimport {\n  getNodesInShortestPathOrder,\n  dijkstra,\n} from \"./algorithms/dijkstra.js\";\nimport \"./App.css\";\n\nconst NUM_ROWS = 20;\nconst NUM_COLUMNS = 50;\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\nconst App = () => {\n  const startNode = useRef();\n  const finishNode = useRef();\n\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        currentRow.push(createNode(row, col));\n        if (row === START_NODE_ROW && col === START_NODE_COL)\n          startNode.current = { row, col };\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\n          finishNode.current = { row, col };\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      isVisited: false,\n      distance: Infinity,\n      previousNode: null,\n    };\n  };\n\n  const [grid, setGrid] = useState(() => getInitialGrid());\n  const [isVisualising, setIsVisualising] = useState(false);\n  const [isPostVisualise, setIsPostVisualise] = useState(false);\n  const visitedNodeOrder = useRef([]);\n  const nodeRefArray = useRef([]);\n  const isResetting = useRef(false);\n  const timeOut = useRef([]);\n  const [isMousePressed, setIsMousePressed] = useState(false);\n  const [isNewStartNode, setIsNewStartNode] = useState(false);\n  const [isNewFinishNode, setIsNewFinishNode] = useState(false);\n\n  useEffect(() => {}, []);\n\n  const handleMouseDown = (row, col) => {\n    setIsMousePressed(true);\n    if (\n      row === startNode.current.row &&\n      col === startNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewStartNode(true);\n    }\n    if (\n      row === finishNode.current.row &&\n      col === finishNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewFinishNode(true);\n    }\n  };\n\n  const handleMouseEnter = (row, col) => {\n    if (!isMousePressed && !isVisualising) return;\n    if (\n      isNewStartNode &&\n      !(row === finishNode.current.row && col === finishNode.current.col)\n    ) {\n      const newGrid = setNewStartOrFinishNode(grid, row, col);\n      setGrid(newGrid);\n    }\n    if (\n      isNewFinishNode &&\n      !(row === startNode.current.row && col === startNode.current.col)\n    ) {\n      const newGrid = setNewStartOrFinishNode(grid, row, col);\n      setGrid(newGrid);\n    }\n  };\n\n  const handleMouseUp = () => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const handleMouseLeave = () => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const setNewStartOrFinishNode = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const prevNode = newGrid[row][col];\n    const currentStartFinishNode = isNewStartNode\n      ? startNode.current\n      : finishNode.current;\n    const type = isNewStartNode ? \"isStart\" : \"isFinish\";\n    const newStartFinishNode = {\n      ...prevNode,\n      [type]: true,\n    };\n    const prevStartFinishNode =\n      newGrid[currentStartFinishNode.row][currentStartFinishNode.col];\n    const rmPrevStartNode = {\n      ...prevStartFinishNode,\n      [type]: false,\n    };\n    newGrid[row][col] = newStartFinishNode;\n    newGrid[currentStartFinishNode.row][\n      currentStartFinishNode.col\n    ] = rmPrevStartNode;\n    if (isNewStartNode) {\n      startNode.current = { row, col };\n    } else {\n      finishNode.current = { row, col };\n    }\n    return newGrid;\n  };\n\n  const animateDijkstra = (visitedNodeOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodeOrder.length; i++) {\n      if (i === visitedNodeOrder.length) {\n        timeOut.current.push(\n          setTimeout(() => {\n            animateShortestPath(nodesInShortestPathOrder);\n          }, 5 * i)\n        );\n        return;\n      }\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = visitedNodeOrder[i];\n          nodeRefArray.current[`${node.row}-${node.col}`].className =\n            \"node node-visited\";\n        }, 5 * i)\n      );\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    let delay = 0;\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      delay = i;\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = nodesInShortestPathOrder[i];\n          nodeRefArray.current[`${node.row}-${node.col}`].className =\n            \"node node-shortest-path\";\n        }, 50 * i)\n      );\n    }\n    timeOut.current.push(setTimeout(() => setIsVisualising(false), 50 * delay));\n    setIsPostVisualise(true);\n  };\n\n  const visualiseDijkstra = () => {\n    // disable if already visualising the algorithm\n    //resetGrid();\n    if (isPostVisualise) resetVisitedNodeCSS();\n    setIsVisualising(true);\n    const nodeStart = grid[startNode.current.row][startNode.current.col];\n    const nodeFinish = grid[finishNode.current.row][finishNode.current.col];\n    visitedNodeOrder.current = dijkstra(grid, nodeStart, nodeFinish);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(nodeFinish);\n    animateDijkstra(visitedNodeOrder.current, nodesInShortestPathOrder);\n  };\n\n  const resetGrid = () => {\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    isResetting.current = true;\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n    resetVisitedNodeCSS();\n  };\n\n  const resetVisitedNodeCSS = () => {\n    const nodeStart = isPostVisualise\n      ? startNode.current\n      : { row: START_NODE_ROW, col: START_NODE_COL };\n    const nodeFinish = isPostVisualise\n      ? finishNode.current\n      : { row: FINISH_NODE_ROW, col: FINISH_NODE_COL };\n    for (let i = 0; i < visitedNodeOrder.current.length; i++) {\n      const node = visitedNodeOrder.current[i];\n      if (node.row === nodeStart.row && node.col === nodeStart.col) {\n        nodeRefArray.current[`${node.row}-${node.col}`].className =\n          \"node node-start\";\n      } else if (node.row === nodeFinish.row && node.col === nodeFinish.col) {\n        nodeRefArray.current[`${node.row}-${node.col}`].className =\n          \"node node-finish\";\n      } else {\n        nodeRefArray.current[`${node.row}-${node.col}`].className = \"node\";\n      }\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <button onClick={() => resetGrid()}>Reset</button>\n      <button disabled={isVisualising} onClick={() => visualiseDijkstra()}>\n        Visualise Dijkstra's Algorithm\n      </button>\n      <div\n        className=\"grid\"\n        onMouseLeave={() => handleMouseLeave()}\n        style={{\n          margin: \"100px auto\",\n          display: \"grid\",\n          gridTemplateColumns: `repeat(${NUM_COLUMNS}, 25px)`,\n          //makes the grid width relative to node dimension\n          width: `${NUM_COLUMNS * 25}px`,\n        }}\n      >\n        {grid.map((row) =>\n          row.map((node) => {\n            const { row, col, isStart, isFinish, isVisited } = node;\n            return (\n              <Node\n                key={`${row}-${col}`}\n                ref={(el) => (nodeRefArray.current[`${row}-${col}`] = el)}\n                handleMouseDown={(row, col) => handleMouseDown(row, col)}\n                handleMouseEnter={(row, col) => handleMouseEnter(row, col)}\n                handleMouseUp={() => handleMouseUp()}\n                row={row}\n                col={col}\n                isStart={isStart}\n                isFinish={isFinish}\n                isVisited={isVisited}\n              ></Node>\n            );\n          })\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}