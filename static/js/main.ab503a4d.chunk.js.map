{"version":3,"sources":["components/Node.jsx","components/Button.jsx","algorithms/dijkstra.js","App.js","reportWebVitals.js","index.js"],"names":["forwardRef","props","ref","row","col","isWall","isStart","isFinish","handleMouseDownForNode","handleMouseEnterForNode","handleMouseUpForNode","handleTouchMoveForNode","displayWeight","isShowWeight","extraClassName","id","onPointerDown","onPointerEnter","onPointerUp","onDragStart","e","preventDefault","stopPropagation","className","Infinity","Button","type","handleFunction","disable","title","disabledTitle","isVisualising","isPostVisualise","text","replace","match","toUpperCase","displayText","displayTitle","shape","disabled","onClick","dijkstra","grid","startNode","finishNode","isRandomWeights","isVisited","finishNodeNeighbours","getUnvisitedNeighbors","finishNodeNeighbourVisits","visitedNodes","distance","cumulativeWeight","unvisitedNodes","nodes","node","push","getAllNodes","heapSortNodesByDistance","closestNode","shift","length","finishNodeNeighbour","filter","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbor","distace","previousNode","neighbors","neighborOperations","totalRows","totalCols","i","operation","newRow","newCol","NUM_COLUMNS","Math","floor","window","innerWidth","START_NODE_COL","FINISH_NODE_COL","App","useRef","getInitialGrid","currentRow","createNode","current","useState","setGrid","setIsVisualising","setIsPostVisualise","visitedNodeOrder","nodeRefArray","isResetting","timeOut","isMousePressed","setIsMousePressed","isStartFinishNode","setIsNewStartNode","isNewFinishNode","setIsNewFinishNode","setWall","newGrid","slice","prevNodeValues","wallNode","setNewStartOrFinishNode","currentStartFinishNode","newStartFinishNode","prevStartFinishNodeValues","prevStartFinishNode","ceil","random","animateShortestPath","nodesInShortestPathOrder","delay","setTimeout","startNodeRow","startNodeCol","visualiseDijkstra","console","log","innerHeight","resetVisitedNodeCSS","nodeStart","nodeFinish","currentNode","unshift","getNodesInShortestPathOrder","nodeRef","innerText","animateDijkstra","randomWeights","isRandomWeightBool","isRestore","finishNodeRow","finishNodeCol","style","display","textAlign","margin","forEach","timer","clearTimeout","initialGrid","resetGrid","restoreGrid","onMouseLeave","gridTemplateColumns","gridTemplateRows","width","touchAction","map","el","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.ab503a4d.chunk.js","sourcesContent":["import React, { forwardRef } from \"react\";\nimport \"./Node.css\";\nimport \"../index.css\";\n\nexport default forwardRef((props, ref) => {\n  const {\n    row,\n    col,\n    isWall,\n    isStart,\n    isFinish,\n    handleMouseDownForNode,\n    handleMouseEnterForNode,\n    handleTouchMoveForNode,\n    handleMouseUpForNode,\n    displayWeight,\n    isShowWeight,\n  } = props;\n  const extraClassName = isFinish\n    ? \"node-finish\"\n    : isStart\n    ? \"node-start\"\n    : isWall\n    ? \"node-wall\"\n    : \"\";\n\n  return (\n    <div\n      id={`${row}-${col}`}\n      onPointerDown={() => {\n        handleMouseDownForNode(row, col);\n      }}\n      onPointerEnter={() => {\n        handleMouseEnterForNode(row, col);\n      }}\n      //onTouchMove={(e) => {\n      //  handleTouchMoveForNode(e);\n      //}}\n      onPointerUp={() => {\n        handleMouseUpForNode();\n      }}\n      onDragStart={(e) => {\n        // Block drag default event\n        e.preventDefault();\n        e.stopPropagation();\n      }}\n      ref={ref}\n      className={`node ${extraClassName}`}\n    >\n      {isStart\n        ? \"\"\n        : isFinish\n        ? \"\"\n        : displayWeight === Infinity\n        ? \"\"\n        : isShowWeight && !isWall\n        ? \"\"\n        : displayWeight}\n    </div>\n  );\n});\n","import React from \"react\";\nimport \"./Button.css\";\n\nexport default function Button(props) {\n  const {\n    type,\n    handleFunction,\n    disable,\n    title,\n    disabledTitle,\n    isVisualising,\n    isPostVisualise,\n  } = props;\n  const text = type\n    .replace(\"-\", \" \")\n    .replace(/(^\\w{1})|(\\s{1}\\w{1})/g, (match) => match.toUpperCase());\n  const displayText =\n    type === \"visualise\" && isPostVisualise && !isVisualising\n      ? \"Revisualise\"\n      : type === \"visualise\" && isVisualising\n      ? \"Visualising\"\n      : text;\n  const displayTitle =\n    type === \"restore\" && disable\n      ? disabledTitle\n      : type === \"random-weights\" && !disable\n      ? title\n      : type === \"random-weights\" && disable\n      ? disabledTitle\n      : \"\";\n  const className = isVisualising\n    ? `${type} visualising loading`\n    : isPostVisualise\n    ? `${type} notify`\n    : type;\n\n  return (\n    <button\n      shape={\"round\"}\n      title={displayTitle}\n      className={className}\n      disabled={disable}\n      onClick={() => handleFunction()}\n    >\n      {isVisualising && <i className={\"spinner\"} />}\n      {displayText}\n    </button>\n  );\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode, isRandomWeights) {\n  finishNode.isVisited = false;\n  finishNode.isWall = false;\n  const finishNodeNeighbours = getUnvisitedNeighbors(finishNode, grid);\n  let finishNodeNeighbourVisits = 0;\n  const visitedNodes = [];\n  startNode.distance = 0;\n  startNode.cumulativeWeight = 0;\n  startNode.isWall = false;\n  const unvisitedNodes = getAllNodes(grid);\n  // terminates when finishNode is reached\n  while (true) {\n    heapSortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodes;\n    closestNode.isVisited = true;\n    visitedNodes.push(closestNode);\n    if (isRandomWeights && finishNodeNeighbours.length > 1) {\n      for (const finishNodeNeighbour of finishNodeNeighbours) {\n        const row = finishNodeNeighbour.row;\n        const col = finishNodeNeighbour.col;\n        if (\n          closestNode.row === row &&\n          closestNode.col === col &&\n          closestNode.isVisited\n        ) {\n          finishNodeNeighbourVisits++;\n        }\n      }\n      if (finishNodeNeighbourVisits === finishNodeNeighbours.length) {\n        finishNodeNeighbours.filter((node) => (node.isVisited = false));\n        return visitedNodes;\n      }\n    } else {\n      if (closestNode === finishNode) return visitedNodes;\n    }\n    updateUnvisitedNeighbors(closestNode, grid, isRandomWeights);\n  }\n}\n\nfunction heapSortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid, isRandomWeights) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    // for weighted simulation\n    if (isRandomWeights) {\n      if (neighbor.distace === Infinity) {\n        neighbor.distance = neighbor.displayWeight + node.cumulativeWeight;\n        neighbor.cumulativeWeight = neighbor.distance;\n        neighbor.previousNode = node;\n      }\n      // checks and updates the neighbors for the path with the less cost\n      else if (\n        neighbor.distance >\n        neighbor.displayWeight + node.cumulativeWeight\n      ) {\n        neighbor.distance = neighbor.displayWeight + node.cumulativeWeight;\n        neighbor.cumulativeWeight = neighbor.distance;\n        neighbor.previousNode = node;\n      }\n    }\n    // for unweighted simulation\n    else {\n      neighbor.distance = node.distance + 1;\n      neighbor.previousNode = node;\n    }\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const { row, col } = node;\n  const neighborOperations = [\n    [0, 1],\n    [1, 0],\n    [0, -1],\n    [-1, 0],\n  ];\n  const totalRows = grid.length;\n  const totalCols = grid[0].length;\n  //constant opeations => 4 values\n  for (let i = 0; i < neighborOperations.length; i++) {\n    const operation = neighborOperations[i];\n    const x = operation[0];\n    const y = operation[1];\n    const newRow = row + x;\n    const newCol = col - y;\n    if (\n      newRow >= 0 &&\n      newRow < totalRows &&\n      newCol >= 0 &&\n      newCol < totalCols &&\n      !grid[newRow][newCol].isWall\n    ) {\n      neighbors.push(grid[newRow][newCol]);\n    }\n  }\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","import React, { useState, useRef } from \"react\";\nimport Node from \"./components/Node.jsx\";\nimport Button from \"./components/Button.jsx\";\nimport {\n  getNodesInShortestPathOrder,\n  dijkstra,\n} from \"./algorithms/dijkstra.js\";\nimport \"./App.css\";\n\nconst NUM_ROWS = 20;\nconst NUM_COLUMNS = Math.floor(window.innerWidth * 0.003) * 10;\nconst NODE_REM = 2;\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = Math.floor(NUM_COLUMNS * 0.25);\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = Math.floor(NUM_COLUMNS * 0.75);\n\nconst App = () => {\n  const startNode = useRef();\n  const finishNode = useRef();\n\n  const getInitialGrid = () => {\n    const grid = [];\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        currentRow.push(createNode(row, col));\n        if (row === START_NODE_ROW && col === START_NODE_COL)\n          startNode.current = { row, col };\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL)\n          finishNode.current = { row, col };\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  const createNode = (\n    row,\n    col,\n    isWall = false,\n    cumulativeWeight = null,\n    startNode = { row: START_NODE_ROW, col: START_NODE_COL },\n    finishNode = { row: FINISH_NODE_ROW, col: FINISH_NODE_COL }\n  ) => {\n    return {\n      row,\n      col,\n      isWall: isWall,\n      isStart: row === startNode.row && col === startNode.col,\n      isFinish: row === finishNode.row && col === finishNode.col,\n      isVisited: false,\n      distance: Infinity,\n      previousNode: null,\n      displayWeight: cumulativeWeight,\n      cumulativeWeight,\n      isShowWeight: false,\n    };\n  };\n\n  const [grid, setGrid] = useState(() => getInitialGrid());\n  const [isVisualising, setIsVisualising] = useState(false);\n  const [isPostVisualise, setIsPostVisualise] = useState(false);\n  const visitedNodeOrder = useRef([]);\n  const nodeRefArray = useRef([]);\n  const isResetting = useRef(false);\n  const isRandomWeights = useRef(false);\n  const timeOut = useRef([]);\n  const [isMousePressed, setIsMousePressed] = useState(false);\n  const [isStartFinishNode, setIsNewStartNode] = useState(false);\n  const [isNewFinishNode, setIsNewFinishNode] = useState(false);\n\n  const handleMouseDownForNode = (row, col) => {\n    setIsMousePressed(true);\n    if (\n      row === startNode.current.row &&\n      col === startNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewStartNode(true);\n    } else if (\n      row === finishNode.current.row &&\n      col === finishNode.current.col &&\n      !isVisualising &&\n      !isPostVisualise\n    ) {\n      setIsNewFinishNode(true);\n    } else if (!isVisualising && !isPostVisualise) setWall(grid, row, col);\n  };\n\n  const handleMouseEnterForNode = (row, col) => {\n    if (!isMousePressed && !isVisualising) return;\n    if (\n      isStartFinishNode &&\n      !(row === finishNode.current.row && col === finishNode.current.col) //&&\n      //!grid[row][col].isWall\n    ) {\n      setNewStartOrFinishNode(grid, row, col);\n    } else if (\n      isNewFinishNode &&\n      !(row === startNode.current.row && col === startNode.current.col) //&&\n      //!grid[row][col].isWall\n    ) {\n      setNewStartOrFinishNode(grid, row, col);\n    } else if (!isVisualising && !isPostVisualise) setWall(grid, row, col);\n  };\n\n  //const handleTouchMoveForNode = (e) => {\n  //  if (!isMousePressed && !isVisualising) return;\n  //  const x = e.touches[0].clientX;\n  //  const y = e.touches[0].clientY;\n  //  const element = document.elementFromPoint(x, y);\n  //  const rowAndCol = element.id.split(\"-\");\n  //  const row = rowAndCol[0];\n  //  const col = rowAndCol[1];\n  //  handleMouseEnterForNode(row, col);\n  //};\n\n  const handleMouseUpForNode = () => {\n    setIsMousePressed(false);\n    setIsNewStartNode(false);\n    setIsNewFinishNode(false);\n  };\n\n  const handleMouseLeaveForGrid = () => {\n    handleMouseUpForNode();\n  };\n\n  const setWall = (grid, row, col) => {\n    const newGrid = grid.slice();\n    const prevNodeValues = newGrid[row][col];\n    const wallNode = {\n      ...prevNodeValues,\n      isWall: !prevNodeValues.isWall,\n    };\n    newGrid[row][col] = wallNode;\n    setGrid(newGrid);\n  };\n\n  const setNewStartOrFinishNode = (grid, row, col) => {\n    const newGrid = grid.slice();\n    // keep the new start or finish nodes previous (json) values\n    const prevNodeValues = newGrid[row][col];\n    const currentStartFinishNode = isStartFinishNode\n      ? startNode.current\n      : finishNode.current;\n    // only change the type of the start or finish node\n    const type = isStartFinishNode ? \"isStart\" : \"isFinish\";\n    const newStartFinishNode = {\n      ...prevNodeValues,\n      isWall: prevNodeValues.isWall,\n      [type]: true,\n    };\n    const prevStartFinishNodeValues =\n      newGrid[currentStartFinishNode.row][currentStartFinishNode.col];\n    // change the old start or finish node type to false\n    const prevStartFinishNode = {\n      ...prevStartFinishNodeValues,\n      displayWeight:\n        prevStartFinishNodeValues.displayWeight === null &&\n        isRandomWeights.current\n          ? Math.ceil(Math.random() * 10)\n          : prevStartFinishNodeValues.displayWeight,\n      [type]: false,\n    };\n    newGrid[row][col] = newStartFinishNode;\n    newGrid[currentStartFinishNode.row][\n      currentStartFinishNode.col\n    ] = prevStartFinishNode;\n    // update start or finish node reference\n    if (isStartFinishNode) {\n      startNode.current = { row, col };\n    } else {\n      finishNode.current = { row, col };\n    }\n    setGrid(newGrid);\n  };\n\n  const animateDijkstra = (visitedNodeOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodeOrder.length; i++) {\n      if (i === visitedNodeOrder.length) {\n        timeOut.current.push(\n          setTimeout(() => {\n            animateShortestPath(nodesInShortestPathOrder);\n          }, 5 * i)\n        );\n        return;\n      }\n      timeOut.current.push(\n        setTimeout(() => {\n          const node = visitedNodeOrder[i];\n          const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n          // displays cumulative weight if in random weight simulation\n          if (isRandomWeights.current)\n            nodeRef.innerText = `${node.cumulativeWeight}`;\n          nodeRef.className = \"node node-visited\";\n        }, 5 * i)\n      );\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    let delay = 0;\n    if (nodesInShortestPathOrder[0].isStart) {\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n        delay = i;\n        timeOut.current.push(\n          setTimeout(() => {\n            const node = nodesInShortestPathOrder[i];\n            nodeRefArray.current[`${node.row}-${node.col}`].className =\n              \"node node-shortest-path\";\n          }, 50 * i)\n        );\n      }\n    } else {\n      const startNodeRow = startNode.current.row;\n      const startNodeCol = startNode.current.col;\n      nodeRefArray.current[`${startNodeRow}-${startNodeCol}`].className =\n        \"node node-start\";\n    }\n    timeOut.current.push(\n      setTimeout(() => {\n        setIsVisualising(false);\n        setIsPostVisualise(true);\n      }, 55 * delay)\n    );\n  };\n\n  const visualiseDijkstra = () => {\n    console.log(window.innerHeight * 0.01);\n    console.log(window.innerWidth * 0.01);\n    // resets css when resimulating\n    if (isPostVisualise) resetVisitedNodeCSS();\n    setIsVisualising(true);\n    const nodeStart = grid[startNode.current.row][startNode.current.col];\n    const nodeFinish = grid[finishNode.current.row][finishNode.current.col];\n    visitedNodeOrder.current = dijkstra(\n      grid,\n      nodeStart,\n      nodeFinish,\n      isRandomWeights.current\n    );\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(nodeFinish);\n    animateDijkstra(visitedNodeOrder.current, nodesInShortestPathOrder);\n  };\n\n  const resetGrid = () => {\n    isRandomWeights.current = false;\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    isResetting.current = true;\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    const initialGrid = getInitialGrid();\n    setGrid(initialGrid);\n    resetVisitedNodeCSS();\n  };\n\n  const resetVisitedNodeCSS = () => {\n    const nodeStart = isPostVisualise\n      ? startNode.current\n      : { row: START_NODE_ROW, col: START_NODE_COL };\n    const nodeFinish = isPostVisualise\n      ? finishNode.current\n      : { row: FINISH_NODE_ROW, col: FINISH_NODE_COL };\n    for (let i = 0; i < visitedNodeOrder.current.length; i++) {\n      const node = visitedNodeOrder.current[i];\n      const nodeRef = nodeRefArray.current[`${node.row}-${node.col}`];\n      if (node.row === nodeStart.row && node.col === nodeStart.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-start\";\n      } else if (node.row === nodeFinish.row && node.col === nodeFinish.col) {\n        nodeRef.innerText = \"\";\n        nodeRef.className = \"node node-finish\";\n      } else {\n        if ((isVisualising || isPostVisualise) && isRandomWeights.current) {\n          nodeRef.innerText = `${node.displayWeight}`;\n        } else {\n          nodeRef.innerText = \"\";\n        }\n        nodeRef.className = \"node\";\n      }\n    }\n  };\n\n  const restoreGrid = (isRestore = true) => {\n    timeOut.current.forEach((timer) => {\n      clearTimeout(timer);\n    });\n    setIsVisualising(false);\n    setIsMousePressed(false);\n    setIsPostVisualise(false);\n    resetVisitedNodeCSS();\n    randomWeights(grid, isRandomWeights.current, isRestore);\n  };\n\n  const randomWeights = (grid, isRandomWeightBool, isRestore = false) => {\n    isRandomWeights.current = isRandomWeightBool;\n    const newGrid = [];\n    const startNodeRow = startNode.current.row;\n    const startNodeCol = startNode.current.col;\n    const finishNodeRow = finishNode.current.row;\n    const finishNodeCol = finishNode.current.col;\n    for (let row = 0; row < NUM_ROWS; row++) {\n      const currentRow = [];\n      for (let col = 0; col < NUM_COLUMNS; col++) {\n        const nodeRef = nodeRefArray.current[`${row}-${col}`];\n        if (row === startNodeRow && col === startNodeCol) {\n          currentRow.push(\n            createNode(\n              startNodeRow,\n              startNodeCol,\n              false,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.innerText = \"\";\n          nodeRef.className = \"node node-start\";\n        } else if (row === finishNodeRow && col === finishNodeCol) {\n          currentRow.push(\n            createNode(\n              finishNodeRow,\n              finishNodeCol,\n              false,\n              null,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.innerText = \"\";\n          nodeRef.className = \"node node-finish\";\n        } else {\n          currentRow.push(\n            createNode(\n              row,\n              col,\n              grid[row][col].isWall,\n              isRestore\n                ? grid[row][col].displayWeight\n                : Math.random() > 0.5\n                ? Math.ceil(Math.random() * 10)\n                : 1,\n              { row: startNodeRow, col: startNodeCol },\n              { row: finishNodeRow, col: finishNodeCol }\n            )\n          );\n          nodeRef.className = grid[row][col].isWall ? \"node node-wall\" : \"node\";\n        }\n      }\n      newGrid.push(currentRow);\n    }\n    setGrid(newGrid);\n  };\n\n  return (\n    <>\n      <div\n        className=\"galaxy-fold-open-your-device\"\n        style={{ display: \"none\" }}\n      ></div>\n      <div className=\"App\">\n        <div\n          className=\"button-container\"\n          style={{\n            textAlign: \"center\",\n            margin: \"3rem auto\",\n          }}\n        >\n          <Button type={\"reset\"} handleFunction={() => resetGrid()}></Button>\n          <Button\n            type={\"restore\"}\n            handleFunction={() => restoreGrid(grid)}\n            disable={!(isVisualising || isPostVisualise)}\n            disabledTitle={\"Restores state before the visualisation\"}\n          ></Button>\n          <Button\n            type={\"random-weights\"}\n            handleFunction={() => randomWeights(grid, true)}\n            disable={isVisualising || isPostVisualise}\n            title={\"Assigns random weights to each node\"}\n            disabledTitle={\"Can only reassign random weights on restore\"}\n          ></Button>\n          <Button\n            type={\"visualise\"}\n            handleFunction={() => visualiseDijkstra()}\n            disable={isVisualising}\n            isVisualising={isVisualising}\n            isPostVisualise={isPostVisualise}\n          ></Button>\n        </div>\n        <div\n          className=\"grid\"\n          onMouseLeave={() => handleMouseLeaveForGrid()}\n          style={{\n            margin: \"auto\",\n            display: \"grid\",\n            gridTemplateColumns: `repeat(${NUM_COLUMNS}, ${NODE_REM}rem)`,\n            gridTemplateRows: `repeat(${NUM_ROWS}, ${NODE_REM}rem)`,\n            //makes the grid width relative to sum of all node pixels\n            width: `${NUM_COLUMNS * NODE_REM}rem`,\n            touchAction: \"none\",\n          }}\n        >\n          {grid.map((row) =>\n            row.map((node) => {\n              const {\n                row,\n                col,\n                isWall,\n                isStart,\n                isFinish,\n                isVisited,\n                displayWeight,\n                cumulativeWeight,\n                isShowWeight,\n              } = node;\n              return (\n                <Node\n                  key={`${row}-${col}`}\n                  ref={(el) => (nodeRefArray.current[`${row}-${col}`] = el)}\n                  handleMouseDownForNode={(row, col) =>\n                    handleMouseDownForNode(row, col)\n                  }\n                  handleMouseEnterForNode={(row, col) =>\n                    handleMouseEnterForNode(row, col)\n                  }\n                  //handleTouchMoveForNode={(e) => handleTouchMoveForNode(e)}\n                  handleMouseUpForNode={() => handleMouseUpForNode()}\n                  row={row}\n                  col={col}\n                  isWall={isWall}\n                  isStart={isStart}\n                  isFinish={isFinish}\n                  isVisited={isVisited}\n                  displayWeight={displayWeight}\n                  cumulativeWeight={cumulativeWeight}\n                  isShowWeight={isShowWeight}\n                ></Node>\n              );\n            })\n          )}\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport reportWebVitals from \"./reportWebVitals\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}